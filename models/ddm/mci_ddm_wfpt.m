function [p] = mci_ddm_wfpt (P,M,U,y)% Wiener First Passage Time (WFPT) density % FORMAT [p] = mci_ddm_wfpt (P,M,U,y)%% P/ddm     parameters in vector form or ddm structure% M         model% U         inputs% y         y(1)=x outcome, y(2)=t reaction time%% p         joint probability density, p(y)=p(x,t)%% This code is based on the wfpt.m function from % Navarro and Fuss (2009) Fast and accurate calculations% for first-passage times in Wiener diffusion models.% Journal of Mathematical Psychology, 53:222-230.%__________________________________________________________________________% Copyright (C) 2016 Wellcome Trust Centre for Neuroimaging% Will Penny% $Id$%       .v     drift rate%       .a     boundary separation%       .b     non-decision time%       .r     starting point (relative)%              Absolute start z= r*a% Truncation error in series expansiontry err=M.truncation_error; catch err=10^(-6); endif ~isstruct(P)    ddm = mci_ddm_from_mci (P,M,U);else    ddm = P;endv=ddm.v;a=ddm.a;b=ddm.b;% Unbiased DDM if r not specifiedtry r = ddm.r; catch r=0.5; end% Remove non-decision timet=y(2)-ddm.b;% If t is less than non-decision time set probability density to zeroif t <= 0    p = eps;    returnendtt=t/(a^2); % use normalized time%w=z/a; % convert to relative start pointw = r;if y(1)    % Correct trial - see p. 224 Navarro and Fuss, 2009    v = -v;    w = 1-w;end% calculate number of terms needed for large tif pi*tt*err<1 % if error threshold is set low enough    kl=sqrt(-2*log(pi*tt*err)./(pi^2*tt)); % bound    kl=max(kl,1/(pi*sqrt(tt))); % ensure boundary conditions metelse % if error threshold set too high    kl=1/(pi*sqrt(tt)); % set to boundary conditionend% calculate number of terms needed for small tif 2*sqrt(2*pi*tt)*err<1 % if error threshold is set low enough    ks=2+sqrt(-2*tt.*log(2*sqrt(2*pi*tt)*err)); % bound    ks=max(ks,sqrt(tt)+1); % ensure boundary conditions are metelse % if error threshold was set too high    ks=2; % minimal kappa for that caseend% compute f(tt|0,1,w)p=0; %initialize densityif ks<kl % if small t is better (i.e., lambda<0)	K=ceil(ks); % round to smallest integer meeting error    for k=-floor((K-1)/2):ceil((K-1)/2) % loop over k        p=p+(w+2*k)*exp(-((w+2*k)^2)/2/tt); % increment sum    end    p=p/sqrt(2*pi*tt^3); % add constant term        else % if large t is better...	K=ceil(kl); % round to smallest integer meeting error	for k=1:K		p=p+k*exp(-(k^2)*(pi^2)*tt/2)*sin(k*pi*w); % increment sum	end	p=p*pi; % add constant termend% convert to f(t|v,a,w)p=p*exp(-v*a*w -(v^2)*t/2)/(a^2); % Prevent logp = NaNp=max(p,eps);